def crawl_single_product_with_stable_new_tab(driver, product_url, product_number, city_name,
                                             continent, country, page_num):
      """🛡️ 세션 안정성이 강화된 새 탭 크롤링 함수 (기존 코드 100% 호환)"""
      main_tab = driver.current_window_handle
      new_tab = None

      try:
          # 🔹 1단계: 세션 유효성 사전 검증
          try:
              driver.current_url  # 세션 상태 확인
              driver.title       # 추가 검증
          except Exception as e:
              print(f"      🚨 세션 무효: {e}")
              return None

          # 🔹 2단계: 안전한 새 탭 생성 (3회 시도)
          for tab_attempt in range(3):
              try:
                  driver.execute_script("window.open('');")
                  all_tabs = driver.window_handles

                  if len(all_tabs) > 1:  # 개선: 단순화
                      new_tab = all_tabs[-1]
                      driver.switch_to.window(new_tab)
                      print(f"      ✅ 새 탭 생성 성공 (시도 {tab_attempt + 1})")
                      break
                  else:
                      print(f"      ⚠️ 새 탭 생성 실패 (시도 {tab_attempt + 1})")

              except Exception as e:
                  print(f"      ❌ 탭 생성 오류 {tab_attempt + 1}: {e}")
                  if tab_attempt < 2:
                      time.sleep(1)
                      continue
                  else:
                      return None

          if not new_tab:
              print(f"      🚨 새 탭 생성 최종 실패")
              return None

          # 🔹 3단계: 상품 페이지 로드 (안정성 강화)
          load_success = False
          for load_attempt in range(3):
              try:
                  driver.get(product_url)

                  # 페이지 로드 완료 대기 (기존 시스템과 호환)
                  timeout = CONFIG.get("PAGE_LOAD_TIMEOUT", 6)
                  if not smart_wait_for_page_load(driver, max_wait=timeout):
                      print(f"      ⚠️ 페이지 로딩 시간 초과, 계속 진행")

                  # 페이지 안정화 대기 추가
                  time.sleep(random.uniform(1, 2))

                  # 세션 유효성 재확인 (offers 포함)
                  current_url = driver.current_url
                  if (product_url in current_url or
                      "products" in current_url or
                      "offers" in current_url):
                      load_success = True
                      print(f"      ✅ 페이지 로드 성공 (시도 {load_attempt + 1})")
                      break
                  else:
                      print(f"      ⚠️ 페이지 로드 의심 (시도 {load_attempt + 1}): {current_url}")

              except Exception as e:
                  print(f"      ❌ 페이지 로드 오류 {load_attempt + 1}: {e}")
                  if load_attempt < 2:
                      time.sleep(2)
                      continue

          if not load_success:
              print(f"      🚨 페이지 로드 최종 실패")
              return None

          # 🔹 4단계: 데이터 수집 (기존 로직 100% 활용)
          try:
              # URL 타입 판별 (기존과 동일)
              url_type = "Product" if "/products/" in product_url else "Offer"

              # 정보 수집 (기존 함수들 그대로 사용)
              product_name = get_product_name(driver, url_type)
              price_raw = get_price(driver)
              price_clean = clean_price(price_raw)
              rating_raw = get_rating(driver)
              rating_clean = clean_rating(rating_raw)
              review_count = get_review_count(driver)
              language = get_language(driver)

              # 도시ID 생성 (기존과 동일)
              city_code = get_city_code(city_name)
              city_id = f"{city_code}_{product_number}"

              # 이미지 다운로드 (기존 시스템 호환)
              if CONFIG.get("SAVE_IMAGES", False):
                  img_info = download_image(driver, product_name, city_name, product_number)
              else:
                  img_info = {
                      'filename': '', 'relative_path': '', 'path': '',
                      'status': 'skipped', 'size': 0
                  }

              print(f"      ✅ 데이터 수집 완료: {product_name[:30]}...")

          except Exception as e:
              print(f"      ❌ 데이터 수집 실패: {e}")
              return None

          # 🔹 5단계: 결과 데이터 생성 (기존 구조 100% 유지)
          result = {
              '번호': product_number,
              '도시ID': city_id,
              '페이지': page_num,
              '대륙': continent,
              '국가': country,
              '도시': city_name,
              '공항코드': city_code,
              '상품타입': url_type,
              '상품명': product_name,
              '가격_원본': price_raw,
              '가격_정제': price_clean,
              '평점_원본': rating_raw,
              '평점_정제': rating_clean,
              '리뷰수': review_count,
              '언어': language,
              '이미지_파일명': img_info.get('filename', ''),
              '이미지_상대경로': img_info.get('relative_path', ''),
              '이미지_전체경로': img_info.get('path', ''),
              '이미지_상태': img_info.get('status', ''),
              '이미지_크기': img_info.get('size', 0),
              'URL': product_url,
              '수집_시간': time.strftime('%Y-%m-%d %H:%M:%S'),
              '상태': '완전수집'
          }

          return result

      except Exception as e:
          print(f"      🚨 크롤링 치명적 오류: {e}")
          return None

      finally:
          # 🔹 6단계: 안전한 탭 정리 및 메인 탭 복귀
          try:
              if new_tab:
                  # 새 탭이 여전히 존재하는지 확인
                  current_tabs = driver.window_handles
                  if new_tab in current_tabs:
                      try:
                          driver.switch_to.window(new_tab)
                          driver.close()
                          print(f"      🗑️ 새 탭 정리 완료")
                      except Exception:
                          print(f"      ⚠️ 새 탭 정리 중 오류 (무시)")

              # 메인 탭으로 안전 복귀
              if main_tab in driver.window_handles:
                  driver.switch_to.window(main_tab)
                  print(f"      🔙 메인 탭 복귀 완료")
              else:
                  # 메인 탭이 없으면 첫 번째 탭으로
                  remaining_tabs = driver.window_handles
                  if remaining_tabs:
                      driver.switch_to.window(remaining_tabs[0])
                      print(f"      🔄 첫 번째 탭으로 복귀")

              # 메모리 정리를 위한 짧은 대기 (기존 시스템과 호환)
              time.sleep(0.5)

          except Exception as cleanup_error:
              print(f"      ⚠️ 탭 정리 중 오류: {cleanup_error}")
              # 정리 실패해도 계속 진행 (기존 동작 유지)