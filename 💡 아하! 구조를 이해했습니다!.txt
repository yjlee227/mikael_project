💡 아하! 구조를 이해했습니다!

  치앙마이의 새로운 검색 시스템은 2단계 구조네요!

  🔍 새로운 검색 플로우 파악

  1단계: 검색 결과 요약 페이지

  - URL: https://www.myrealtrip.com/search?q=%EC%B9%98%EC%95%99%EB%A7%88%EC%9D%B4
  - 내용: 여러 카테고리별 상품 미리보기
  - 투어・티켓 섹션: "536개 더보기" 버튼 존재

  2단계: 목록페이지

  - "536개 더보기" 버튼 클릭 → 실제 목록페이지로 이동
  - 여기서부터 스크롤 또는 페이지네이션 방식

  🛠️ 필요한 대응 방안

  A. 새로운 검색 플로우 함수

  def navigate_to_product_list_new_system(driver, city_name):
      """새로운 검색 시스템에서 상품 목록페이지로 이동"""

      # 1. 검색 실행 (기존 방식)
      perform_new_search(driver, city_name)

      # 2. "더보기" 버튼 찾기 및 클릭
      more_buttons = [
          "//button[contains(text(), '더보기')]",
          "//a[contains(text(), '더보기')]",
          "//button[contains(text(), '개 더보기')]",
          "//span[contains(text(), '투어・티켓')]/following::button[contains(text(), '더보기')]"
      ]

      for selector in more_buttons:
          try:
              button = driver.find_element(By.XPATH, selector)
              if button.is_displayed() and button.is_enabled():
                  print(f"✅ '{button.text}' 버튼 발견, 클릭 중...")
                  button.click()
                  time.sleep(3)
                  return True
          except:
              continue

      print("❌ 더보기 버튼을 찾을 수 없습니다")
      return False

  B. 적응형 검색 시스템

  def adaptive_search_and_navigate(driver, city_name):
      """도시별 검색 방식 자동 선택"""

      # 1. 기존 방식 시도
      try:
          perform_new_search(driver, city_name)  # 기존 함수

          # 바로 목록페이지인지 확인
          product_links = driver.find_elements(By.CSS_SELECTOR, "a[href*='/products/']")
          if len(product_links) >= 10:
              print(f"✅ {city_name}: 기존 시스템 (바로 목록페이지)")
              return "direct_list"

      except Exception as e:
          print(f"❌ 기존 방식 실패: {e}")

      # 2. 새로운 방식 시도 (더보기 버튼)
      if navigate_to_product_list_new_system(driver, city_name):
          print(f"✅ {city_name}: 새로운 시스템 (더보기 버튼 경유)")
          return "button_navigation"

      print(f"⚠️ {city_name}: 두 방식 모두 실패")
      return "failed"

  🎯 그룹 11 업데이트된 설계

  핵심 기능

  1. 🔍 검색 방식 감지: 직접 목록 vs 더보기 버튼 필요
  2. 🔘 더보기 버튼 처리: "536개 더보기" 같은 버튼 자동 클릭
  3. 🔄 적응형 네비게이션: 도시별 최적 경로 선택
  4. 📊 호환성 유지: 기존 그룹들과 완전 호환

  이제 정확한 구조를 파악했으니 그룹 11을 구현해보시겠어요?

  더보기 버튼까지 고려한 완전한 적응형 시스템이 될 것 같습니다! 🚀

> 목록페이이지가 나오면 무한 스크롤 형식으로 상품목록이 보임

● 🎯 완전한 플로우 파악 완료!

  이제 치앙마이의 새로운 시스템 전체 구조를 이해했습니다!

  📱 치앙마이 새로운 크롤링 플로우

  1. 검색 실행
     ↓
  2. 검색 결과 요약 페이지 (여러 카테고리 미리보기)
     ↓
  3. "536개 더보기" 버튼 클릭
     ↓
  4. 실제 목록페이지 (무한 스크롤 형식)
     ↓
  5. 스크롤 다운하며 상품 수집

  🛠️ 그룹 11: 완전한 적응형 크롤링 시스템

  # =============================================================================
  # 🆕 그룹 11: 마이리얼트립 새로운 검색 시스템 대응 (2025-07-31)
  # - 2단계 검색 플로우: 검색 → 더보기 버튼 → 무한스크롤 목록
  # - 기존 페이지네이션과 새로운 스크롤 방식 모두 지원
  # - 도시별 자동 감지 및 적응형 크롤링
  # =============================================================================

  def detect_search_system_type(driver, city_name):
      """검색 시스템 타입 감지"""
      current_url = driver.current_url

      # URL 패턴으로 1차 판별
      if '/search?q=' in current_url:
          # 더보기 버튼이 있는지 확인
          more_buttons = driver.find_elements(By.XPATH, "//button[contains(text(), '더보기')]")
          if more_buttons:
              return 'two_step_scroll'  # 2단계 스크롤 방식
          else:
              return 'direct_scroll'    # 직접 스크롤 방식

      elif '/offers?' in current_url or '/experiences?' in current_url:
          return 'pagination'  # 기존 페이지네이션

      else:
          return 'unknown'

  def navigate_to_scroll_list(driver, city_name):
      """새로운 시스템에서 무한스크롤 목록페이지로 이동"""

      print(f"🔍 {city_name}: 더보기 버튼 찾는 중...")

      # 더보기 버튼 셀렉터들
      more_button_selectors = [
          "//button[contains(text(), '더보기')]",
          "//button[contains(text(), '개 더보기')]",
          "//span[contains(text(), '투어')]/ancestor::section//button[contains(text(),
  '더보기')]",
          "//span[contains(text(), '티켓')]/ancestor::section//button[contains(text(),
  '더보기')]",
          "[data-testid*='more'] button",
          ".show-more-button"
      ]

      for selector in more_button_selectors:
          try:
              if selector.startswith('//'):
                  buttons = driver.find_elements(By.XPATH, selector)
              else:
                  buttons = driver.find_elements(By.CSS_SELECTOR, selector)

              for button in buttons:
                  if button.is_displayed() and button.is_enabled():
                      button_text = button.text.strip()
                      if '더보기' in button_text:
                          print(f"✅ '{button_text}' 버튼 발견, 클릭 중...")

                          # 버튼이 보이도록 스크롤
                          driver.execute_script("arguments[0].scrollIntoView(true);", button)
                          time.sleep(1)

                          # 클릭
                          button.click()
                          time.sleep(random.uniform(3, 5))

                          # 목록페이지 로딩 대기
                          WebDriverWait(driver, 10).until(
                              lambda d: len(d.find_elements(By.CSS_SELECTOR,
  "a[href*='/products/']")) > 5
                          )

                          print(f"✅ 무한스크롤 목록페이지 이동 완료")
                          return True

          except Exception as e:
              continue

      print(f"❌ 더보기 버튼을 찾을 수 없습니다")
      return False

  def scroll_and_collect_infinite(driver, city_name, target_count=50):
      """무한스크롤 방식으로 상품 수집"""

      print(f"🔄 {city_name}: 무한스크롤 상품 수집 시작 (목표: {target_count}개)")

      collected_urls = []
      last_count = 0
      scroll_attempts = 0
      max_scroll_attempts = 20

      while len(collected_urls) < target_count and scroll_attempts < max_scroll_attempts:

          # 현재 페이지의 상품 URL 수집
          current_urls = collect_product_urls_from_page(driver)

          # 중복 제거하며 누적
          for url in current_urls:
              if url not in collected_urls:
                  collected_urls.append(url)

          print(f"    📊 현재 수집: {len(collected_urls)}개 / 목표: {target_count}개")

          # 목표 달성 시 종료
          if len(collected_urls) >= target_count:
              break

          # 더 이상 새로운 상품이 로딩되지 않으면 종료
          if len(collected_urls) == last_count:
              scroll_attempts += 1
              print(f"    ⚠️ 새로운 상품 없음 (시도 {scroll_attempts}/{max_scroll_attempts})")
          else:
              scroll_attempts = 0  # 새로운 상품 발견 시 카운터 리셋

          last_count = len(collected_urls)

          # 스크롤 다운
          print(f"    🔽 스크롤 다운...")
          driver.execute_script("window.scrollTo(0, document.body.scrollHeight);")
          time.sleep(random.uniform(2, 4))  # 로딩 대기

      final_urls = collected_urls[:target_count]
      print(f"✅ {city_name}: 무한스크롤 수집 완료 ({len(final_urls)}개)")

      return final_urls

  def adaptive_crawl_system(driver, city_name, target_count=50):
      """🎯 완전 적응형 크롤링 시스템"""

      print(f"🚀 {city_name}: 적응형 크롤링 시작")

      # 1. 검색 시스템 타입 감지
      system_type = detect_search_system_type(driver, city_name)
      print(f"🔍 감지된 시스템: {system_type}")

      # 2. 시스템 타입별 크롤링 실행
      if system_type == 'two_step_scroll':
          # 새로운 2단계 스크롤 시스템
          if navigate_to_scroll_list(driver, city_name):
              return scroll_and_collect_infinite(driver, city_name, target_count)
          else:
              print(f"❌ 2단계 스크롤 실행 실패")
              return []

      elif system_type == 'direct_scroll':
          # 직접 스크롤 시스템
          return scroll_and_collect_infinite(driver, city_name, target_count)

      elif system_type == 'pagination':
          # 기존 페이지네이션 시스템
          print(f"📄 기존 페이지네이션 시스템 사용")
          return crawl_with_full_pagination(city_name, target_count)

      else:
          # 알 수 없는 시스템 - 순차적 시도
          print(f"❓ 알 수 없는 시스템 - 순차 시도")

          # 먼저 2단계 스크롤 시도
          if navigate_to_scroll_list(driver, city_name):
              return scroll_and_collect_infinite(driver, city_name, target_count)

          # 실패하면 기존 페이지네이션 시도
          try:
              return crawl_with_full_pagination(city_name, target_count)
          except:
              print(f"🚨 모든 방식 실패")
              return []

  print("✅ 그룹 11 완료: 완전 적응형 크롤링 시스템!")
  print("🔧 지원 기능:")
  print("   - 2단계 스크롤 시스템 (검색 → 더보기 → 무한스크롤)")
  print("   - 직접 스크롤 시스템")
  print("   - 기존 페이지네이션 시스템")
  print("   - 자동 감지 및 적응형 실행")
  print("🎯 모든 도시의 시스템 변화에 대응 가능!")